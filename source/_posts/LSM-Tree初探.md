---
title: LSM-Tree初探
date: 2021-01-18 11:25:05
tags:
categories: 分布式系统
---

在阅读《数据密集型应用系统设计》的时候，接触到了LSM-Tree。觉得书中讲述的十分简略，没能深入理解这个存储结构。打算单独拎出来写一篇笔记。

# LSM-Tree背景

传统关系型数据库使用B-Tree或者一些变体作为存储结构，但这有一个缺点：有的数据逻辑上相离很近但是物理上相离甚远，这就会导致大量的**磁盘随机读写**。而随机读写比顺序读写要慢很多，为了提升IO性能，我们需要一种能将随机操作变为顺序操作的机制。这就有了LSM-Tree的诞生。LSM树能让我们进行顺序写磁盘，从而大幅提升写操作，作为代价的是牺牲了一些读性能。

# LSM-Tree原理

LSM-Tree实际上和Tree的关系不大，它是一种分层的存储结构。

## 组件介绍

LSM-Tree由两个或更多的类Tree组成。我们暂时先讨论最简单的两个组件的情况

{% asset_img LSM-Tree两组件.png LSM-Tree两组件 %}

LSM-Tree有两部分：

* 一个较小的位于**内存**的组件，就是C0 Tree
* 一个较大的位于**磁盘**的组件，就是C1 Tree



历史记录表的数据每生成一行新纪录流程如下：

1. 首先向顺序日至文件中写一条用于恢复这次插入行为的日志记录

2. 该行数据的索引被插入到常驻内存的C0 Tree

3. 会适时地将这些C0 Tree上的数据迁移到磁盘上的C1 Tree中

4. 每个索引的搜索过程都是先C0后C1

   

## 组件合并

### C0 合并到 C1

当C0 Tree上的插入数据达到一个指定阈值时，有一个持续循环的合并进程服务会删除C0 Tree上的一些连续segment段，将他们合并到磁盘中的C1 Tree。

{% asset_img C0合并至C1.png C0合并至C1 %}



|        | 大小  | 描述                                                         | 用途                                               |
| ------ | ----- | ------------------------------------------------------------ | -------------------------------------------------- |
| 单页块 | 4KB   | 根节点；每个层级上的单页节点                                 | 单页节点被用在匹配索引查找中，以最小化缓存需求     |
| 多页块 | 256KB | 根目录下的每个层级上的单页节点序列会被打包，然后一起放入连续的多页磁盘块中（囊括了根节点以下的节点），利于磁盘顺序访问 | 多页块IO，在滚动合并期间、大范围的范围搜索中被使用 |



### Empty Block和Filling Block

> Empty Block: 在合并前，已缓存、且包含旧的C1 Tree节点的多页块。意味着它们会被清空、移除。
>
> Filling Block: 新的叶节点被写入与旧的多页块不同的**已缓存**的多页块。意味着它们会被填满。



1. 从C1中读取未合并叶子节点，放置在内存中的 `empty block` 中
2. 从小到大找C0中的节点，与 `empty block` 进行合并排序，合并结果保存到`filling block`中，并将C0对应的节点删除。
3. 不断执行第2步操作，合并排序结果不断填入 `filling block` 中，当其满了则将其追加到磁盘的新位置上，注意是追加而不是改变原来的节点。合并期间如故宫 `empty block` 使用完了则再从C1中读取未合并的叶子节点。
4. C0和C1所有叶子节点都按以上合并完成后即完成一次合并。

具体插入例子可见：

[看图轻松理解数据结构与算法系列（NoSQL存储-LSM树）](https://juejin.cn/post/6844903688075477000)



## LSM Tree 索引查找

### 搜索原则 

> C<sub>0</sub> Tree 是驻留在内存中的，而其他组件都在磁盘。这种情况下，每当C<sub>i-1</sub> 条目达到阈值时，每个 (C<sub>i-1</sub>, C<sub>i</sub>) 之间的异步滚动合并过程会从较小的组件中移动条目到较大的组件。



{% asset_img LSM-Tree多组件.png LSM-Tree多组件 %}



当一个需要立刻返回的精确匹配查询或是范围查询在LSM Tree的索引上执行时，会先在C<sub>0</sub>树执行搜索值，然后搜C<sub>1</sub>树。这暗含着少许额外的CPU开销(相对于B-Tree来说)，因为分别去两棵树目录进行搜索。



## LSM Tree 删除、更新

### 删除

删除操作为了能快速执行，主要是通过标记来实现，在内存中将要删除的记录标记一下，后面异步执行合并时将相应记录删除。

* 比如要删除“U”，假设标为#的表示删除，则C0树的“U”节点变为“U(#)”
* 而如果C0树不存在的记录，则在C0树中生成一个节点，并标为#，查找时就能再内存中得知该记录已被删除，无需去磁盘找了。比如要删除“B”，那么没有必要去磁盘执行删除操作，直接在C0树中插入一个“B”节点，并标为#。



### 更新

导致索引值更改的记录更新，这在任何类型的应用程序中都是不常见的。但如果我们将更新视为删除后紧跟着插入，则可以由LSM树以延迟方式处理此类更新。



# 参考文献

* [看图轻松理解数据结构与算法系列（NoSQL存储-LSM树）](https://juejin.cn/post/6844903688075477000)
* [论文阅读-The Log-Structured Merge-Tree](https://my.oschina.net/u/4064459/blog/2999407)

