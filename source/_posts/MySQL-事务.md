---
title: MySQL-事务
date: 2021-01-04 16:55:21
tags: MySQL
categories: 数据库
---

# 数据库ACID特性
## 原子性 Atomicity
一个事务必须被视为一个不可分割的最小工作单元，整个事务中的所有操作要么全部提交成功，要么全部回滚失败。
## 一致性 Consistency
数据库总是从一个一致性状态转换到另一个一致性状态。
## 隔离性 Isolation
一个事务在做提交之前，对其他事物是不可见的。
## 持久性
一旦事务提交，其所作的修改就会永久的保存在数据库中。

# MVCC 多版本并发控制
我们在数据库表中看到的一行记录可能实际上有多个版本，每个版本的记录除了有数据本身外，还要有一个表示版本的字段 ```row trx_id```，这个字段就是使其产生的事务id，记为 ```transcation id```，在事务开始的时候向事务系统申请，按时间顺序递增。

{% asset_img 事务ID.png 事务ID %}




可以认为 MVCC 是行级锁的一个变种，但它在很多情况下避免了加锁操作，因此开销更低。虽然实现机制有所不同，但大都实现了非阻塞的读操作，写操作也只是锁定必要的行。

<b>MVCC 的实现是通过保存数据在某个时间点的快照来实现的。</b>也就是说不管需要执行多长时间，每个事物看到的数据都是一致的。

典型的MVCC实现方式，分为乐观（optimistic）并发控制和悲观（pressimistic）并发控制。下边通过 InnoDB的简化版行为来说明 MVCC 是如何工作的。

InnoDB 的 MVCC，是通过在每行记录后面保存两个隐藏的列来实现。这两个列，一个保存了行的创建时间，一个保存行的过期时间（删除时间）。当然存储的并不是真实的时间，而是系统版本号（system version number）。每开始一个新的事务，系统版本号都会自动递增。事务开始时刻的系统版本号会作为事务的版本号，用来和查询到的每行记录的版本号进行比较。

* SELECT
    * InnoDB会根据以下两个条件检查没行记录：
        * a. InnoDB只会查找版本早于当前事务版本的数据行（也就是，行的系统版本小于或等于事务的系统版本号），
   这样可以确保事务读取到的行，要么是事务开始前已经存在的，要么是事务自身插入或者修改过的。
        * b. 行的删除版本要么未定义，要么大于当前事务的版本号。这样可以确保事务读取到的行，在事务之前未被
   删除。
   只有符合上述两个条件的记录，才能被作为返回查询结果
* INSERT
	* InnoDB 为新插入的每一行保存当前系统版本号作为行版本号
* DELETE
	* InnoDB 为删除的每一行保存当前系统版本号作为行删除标识
* UPDATE
	* InnoDB 为插入一行新纪录，保存当前系统版本号作为版本号，同时保存当前系统版本号到原来的行作为行删除标识。

# 隔离性
## 数据库事务隔离级别

|    			            |  脏读  | 不可重复读 | 幻读   |
|  --------------  | ----  | -------- | ----  |
| Read Uncommitted | 可能    | 可能         | 可能    |
| Read Committed    | 不可能 |  可能        | 可能    |
| Repeatable Read    | 不可能 | 不可能      | 可能    |
| Serializable 	     | 不可能 | 不可能      | 不可能 |

### 脏读、不可重复读、幻读
* 脏读

	脏读就是指当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据。
	
* 不可重复读

	是指在一个事务内，多次读同一数据。在这个事务还没有结束时，另外一个事务也访问该同一数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改，那么第一个事务两次读到的的数据可能是不一样的。这样就发生了在一个事务内两次读到的数据是不一样的，因此称为是不可重复读。（即不能读到相同的数据内容）
	
	例如，一个编辑人员两次读取同一文档，但在两次读取之间，作者重写了该文档。当编辑人员第二次读取文档时，文档已更改。原始读取不可重复。如果只有在作者全部完成编写后编辑人员才可以读取文档，则可以避免该问题。

* 幻读

	是指当事务不是独立执行时发生的一种现象，例如第一个事务对一个表中的数据进行了修改，这种修改涉及到表中的全部数据行。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入一行新数据。那么，以后就会发生操作第一个事务的用户发现表中还有没有修改的数据行，就好象发生了幻觉一样。

	例如，一个编辑人员更改作者提交的文档，但当生产部门将其更改内容合并到该文档的主复本时，发现作者已将未编辑的新材料添加到该文档中。如果在编辑人员和生产部门完成对原始文档的处理之前，任何人都不能将新材料添加到文档中，则可以避免该问题。

### 四种隔离级别的解读
#### Read Uncommitted
最差的隔离级别，一个事务可以读到另一个事务没有commit时的数据

#### Read Committed
当隔离级别设置为Read committed 时，一个事务虽然不能读未commit的数据，但是别的事务可以修改当前读过的数据，造成前后不一致。大多数数据库的默认级别就是Read committed，比如Sql Server , Oracle。

#### Repeatable Read
虽然Repeatable read避免了不可重复读，但还有可能出现幻读 。

#### Serializable
Serializable 是最高的事务隔离级别，同时代价也花费最高，性能很低，一般很少使用，在该级别下，事务顺序执行，不仅可以避免脏读、不可重复读，还避免了幻像读。

## 快照 (Snapshot)
快照又叫一致性视图，快照需要遵循以下规则：
* 当前事务内的更新，可读
* 版本未提交，不可读
* 版本已提交，但是在快照创建后提交的，不可读
* 版本已提交，且是在快照创建前提交的，可读

### 快照读 vs. 当前读
* 快照读
  * 读取的是记录数据的可见版本（可能是过期的数据），不用加锁
* 当前读
  * 读取的是记录数据的最新版本，并且当前读返回的记录都会加上锁，保证其他事务不会再并发的修改这条记录


## 隔离的实现

### 四种隔离级别的实现
#### 读未提交 (Read Uncommitted)
这种隔离性是不加锁的。
#### 串行化
读的时候加共享锁(其他事务可以并发读)，但是不能写；写的时候加排他锁，其他事务不能并发写也不能并发读。
#### 读提交 (Read Committed)
而读提交则是每次执行语句的时候都重新生成一次快照。

#### 可重复读 (Repeatable Read)
可重复读是在事务开始的时候生成一个当前事务全局性的快照。

### 并发写问题
更新之前要先读取数据，这里用的是**当前读**，总是当前版本的数据，也就是多版本中最新一次提交的那版。

假设事务A要执行 update 操作，需要对所修改的行加行锁，这个行锁会在提交之后才释放。这时候事务B就没办法更新这行，直到事务A提交后释放行锁。

加锁过程要分有索引和无索引
* 有索引
  * MySQL 直接就在索引数中找到了这行数据，然后干净利落的加上行锁就可以了。
* 无索引
  * MySQL 会为这张表中**所有行**加行锁，在加上行锁后，MySQL 会进行一遍过滤，发现不满足的行就释放锁，最终只留下符合条件的行。

### 解决幻读
> MySQL 如果使用 InnoDB 是可以在可重复读隔离级别下解决幻读问题。MyISAM 是不支持行级锁的，所以还会出现幻读的问题。

MySQL 把行锁和间隙锁合并在一起，解决了并发写和幻读的问题，这个锁叫做 Next-Key 锁。

假设现在表中有两条记录，并且 age 字段已经添加了索引，两条记录 age 的值分别为 10 和 30。

{% asset_img 幻读-1.png 幻读-1 %}

此时，在数据库中会为索引维护一套 B+ 树，用来快速定位行记录。

{% asset_img 幻读-2.png 幻读-2 %}

如图所示，分成了3 个区间，(负无穷,10]、(10,30]、(30,正无穷]，在这3个区间是可以加间隙锁的。

之后，我用下面的两个事务演示一下加锁过程。

{% asset_img 幻读-3.png 幻读-3 %}

在事务A提交之前，事务B的插入操作只能等待，这就是间隙锁起得作用。当事务A执行```update user set name='风筝2号’ where age = 10;``` 的时候，由于条件 where age = 10 ，数据库不仅在 age = 10 的行上添加了行锁，而且在这条记录的两边，也就是(负无穷,10]、(10,30]这两个区间加了间隙锁，从而导致事务B插入操作无法完成，只能等待事务A提交。不仅插入 age = 10 的记录需要等待事务A提交，age < 10、10 < age < 30 的记录页无法完成，而大于等于30的记录则不受影响，这足以解决幻读问题了。

这是有索引的情况，如果 age 不是索引列，那么数据库会为整个表加上间隙锁。所以，如果是没有索引的话，不管 age 是否大于等于30，都要等待事务A提交才可以成功插入。


# 参考文献
[一文讲清楚MySQL事务隔离级别和实现原理](https://www.cnblogs.com/fengzheng/p/12557762.html)


