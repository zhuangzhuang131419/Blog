---
title: 《现代操作系统》-读书笔记
date: 2021-04-22 11:41:27
category: 操作系统
tags: [读书笔记,现代操作系统]
---



# 进程与线程

## 进程

### 进程模型

> 在进程模型中，计算机上所有可运行的软件，通常也包括操作系统，被组织成若干**顺序进程**，简称**进程**。

* 一个进程就是一个正在执行程序的实例，包括程序计数器、寄存器和变量当前值。

* 一个进程是某种类型的一个活动，它有程序、输入、输出以及状态。单个处理器可以被若干进程共享，它使用某种调度算法决定何时停止一个进程的工作，并转而为另一个进程提供服务。



### 进程的创建

* 4种主要事件会导致进程的创建
  * 系统初始化
  * 正在运行的程序执行了创建进程的系统调用
  * 用户请求创建一个新进程
  * 一个批处理作业的初始化

* 停留在后台处理诸如电子邮件、Web页面、新闻、打印之类活动的进程称为**守护进程（daemon）**

* 在UNIX系统中，只有一个系统调用可以用来创建新进程：`fork`
  * 进程创建之后，父进程和子进程有各自不同的地址空间。修改对其他进程是不可见的。
  * 在UNIX中，子进程的初始地址空间是父进程的一个副本，不可写的内存区是共享的。或者，子进程共享父进程的所有内存，但这种情况下内存通过**写时复制**共享。
  * **可写的内存是不可以共享的**。



### 进程的终止

* 以下条件会引起一个进程的终止：
  * 正常退出（自愿）
  * 出错退出（自愿）
  * 严重错误（非自愿）
  * 被其他进程杀死（非自愿）



### 进程的层次结构

* 进程只有一个父进程。
* 在UNIX中，进程和它的所有子进程以及后裔共同组成一个进程组。



### 进程的状态

{% asset_img 进程的状态.png 进程的状态 %}

* 进程的三种状态是：
  * 运行态：该时刻进程实际占用CPU
  * 就绪态：可运行，但因为其他进程正在运行而暂时停止
  * 阻塞态：除非某种外部事件发生，否则进程不能运行



### 进程的实现

* 操作系统维护着一张表格，即进程表。每个进程占用一个进程表项。
* 该表项包含了进程状态的重要信息，包括程序计数器、堆栈指针、内存非配状况、所打开文件的状态、账号和调度信息吗，以及其他在进程由运行态转换到就绪态或阻塞态时必须保存的信息，从而保证该进程随后能再次启动，就像从未被中断过一样。
* 与每一I/O类关联的是一个称作**中断向量**的位置。
  * 中断向量包含中断服务程序的入口地址。
  * 中断发生后操作系统最底层的工作步骤：
    1. 中断硬件将程序计数器、程序状态字等压入堆栈
    2. 硬件从中断向量装入新的程序计数器
    3. 汇编语言过程保存寄存器值
    4. 汇编语言过程设置新的堆栈
    5. C中断服务例程运行
    6. 调度程序决定下一个将运行的进程
    7. C过程返回至汇编代码
    8. 汇编语言过程开始运行新的当前进程



### 多道程序设计模型





## 线程

> 在传统的操作系统中，每个进程有一个地址空间和一个控制线程。



### 线程的使用

* 引入线程的原因
  * 需要一种并行实体拥有共享同一个地址空间和所有可用数据的能力
  * 线程比进程更轻量级，所以它们比进程更容易创建和销毁。
  * 如果存在大量的计算和大量的I/O处理，拥有多个线程允许活动彼此重叠进行，可以提升性能
* 构造服务器的三种方法：
  * 多线程：并行性、阻塞系统调用
  * 单线程进程：无并行性、阻塞系统调用
  * 有限状态机：并行性、非阻塞系统调用、中断



### 经典的线程模型

* 各个线程都可以访问进程地址空间中的每一个内存地址。（线程之间是没有保护的）
* 每个进程中的内容
  * 地址空间
  * 全局变量
  * 打开文件
  * 子进程
  * 即将发生的定时器
  * 信号与信号处理程序
  * 账户能力
* 每个线程中的内容
  * 程序计数器
  * 寄存器
  * 堆栈
  * 状态
* 资源管理的单位是进程而非线程



> Q: UNIX中的fork系统调用。如果父进程有多个线程，那么它的子进程也应该拥有这些线程吗？
>
> A: 如果不是，则该子进程可能会工作不正常；如果是，父进程在read系统调用上被阻塞了会发生什么情况？



#### 常见的线程调用

* `thread_create`
  * 进程通常会从当前的单个线程开始。这个线程可以通过调用`thread_create`创建新的线程
* `thread_exit`
  * 当一个线程完成工作，可以通过调用`thread_exit`退出
* `thread_join`
  * 一个线程可以等待一个特定的线程退出。
* `thread_yielf`
  * 它允许线程自动放弃CPU从而让另一个线程运行。



### POSIX线程

| 线程调用             | 描述                           |
| -------------------- | ------------------------------ |
| pthread_create       | 创建一个新线程                 |
| pthread_exit         | 结束调用的线程                 |
| pthread_join         | 等待一个特定的线程退出         |
| pthread_yield        | 释放CPU来运行另外一个线程      |
| pthread_attr_init    | 创建并初始化一个线程的属性结构 |
| pthread_attr_destroy | 删除一个线程的属性结构         |



### 在用户空间中实现线程

把整个线程包放在用户空间中，内核对线程包一无所知。

{% asset_img 用户级线程包和内核管理的线程包.png 用户级线程包和内核管理的线程包 %}

* 在用户空间管理线程时，每个进程需要有其专用的**线程表**
* 使用用户级线程包的优点：
  * 进行一个线程切换比陷入内核要快
  * 允许每个进程有自己定制的调度算法
* 使用用户级线程包的缺点：
  * 难以实现阻塞系统调用（要允许每个线程使用阻塞调用，还要避免被阻塞的线程影响其他的线程）
  * 如果一个线程开始运行，那么在该进程中的其他线程就不能运行，除非第一个线程自动放弃CPU
    * 在一个单独的进程内部，没有时钟中断，所以不可能用轮转调度的方式调度线程
  * 我们通常在经常发生线程阻塞的应用中才希望使用多个线程。对于那些基本上是CPU密集型而且极少有阻塞的应用程序而言，没有使用多线程的意义。



### 在内核中实现线程

* 当某个线程希望创建一个新线程或撤销一个已有线程时，它进行了一个系统调用，这个系统调用通过对线程表的更新完成线程创建或撤销工作。
* 当一个线程阻塞时，内核根据其选择，可以运行同一个进程中的另一个线程或者运行另一个进程中的线程。而在用户级线程中，运行时系统始终运行自己进程中的线程，直到内核剥夺它的CPU为止。
* 信号是发给进程而不是线程的。



### 混合实现

使用内核级线程，然后将用户级线程与某些或者全部内核线程多路复用起来。

{% asset_img 用户级线程与内核线程多路复用.png 用户级线程与内核线程多路复用 %}

* 内核只识别内核级线程，并对其进行调度
* 其中一些内核级线程会被多个用户级线程多路复用



### 调度程序激活机制

> 调度程序激活工作的目标是模拟内核线程的功能，但是为线程包提供通常在用户空间中才能实现的更好的性能和更大的灵活性。

* 如果用户线程从事某种系统调用时是安全的，那就不应该进行专门的非阻塞调用或者进行提前检查



### 使单进程代码多线程化

把单进程的代码多线程化会碰到以下问题：

* 针对全局变量（对线程而言是全局变量，并不是对整个程序是全局的）
  * 禁用全局变量
  * 为每个线程赋予其私有的全局变量
  * 可以引入新的库过程，以便创建、设置和读取这些线程范围的全局变量
* 有许多库并不是可重入的
  * 为每个过程提供一个包装器，该包装器设置一个二进制位从而标志某个库处于使用中
* 对于信号的捕捉应该用什么线程



## 进程间通信

* 一个进程如何把信息传递给另一个
* 确保两个或更多的进程在关键活动中不会出现交叉
* 与正确的顺序有关



### 竞争条件

> 两个或多个进程读写某些共享数据，而最后的结果取决于进程运行的精确时序，称为**竞争条件**。



### 临界区

* 可以通过**互斥**的手段来避免**竞争条件（condition race）**。
* 把对共享内存进行访问的片段称作**临界区域（critical region）**。使两个进程不可能同时处于临界区中，就能够避免竞争条件。



### 忙等待的互斥

有以下几种实现互斥的方案：



#### 屏蔽中断

使每个进程在刚刚进入临界区后立即屏蔽所有中断，并在就要离开之前在打开中断。CPU只有发生时钟中断或其他中断时才会进行进程切换，这样，在屏蔽中断之后CPU将不会被切换到其他进程。



缺点：

屏蔽中断对于操作系统本身而言是一项很有用的技术，但对于用户进程则不是一种合适的通用互斥机制。



#### 锁变量

进入临界区之前，先读取锁变量的值。



缺点：

可能会导致领个进程进入临界区



### 严格轮换法

```java
// Thread A
while (true) {
  while (turn != 0) {
    critical_region();
  }
  turn = 1;
  noncritical_region();
}


// Thread B
while (true) {
  while (turn != 1) {
    critical_region();
  }
  turn = 0;
  noncritical_region();
}
```



* 连续测试一个变量直到某个值出现为止，称为**忙等待（busy waiting）**。
* 但这种方式非常消耗CPU资源，只有在有理由认为等待时间是非常短的情况下，才使用忙等待。用于忙等待的锁，称为**自旋锁（spin lock）**。



缺点：

* 只能轮流，在一个进程比另一个进程慢很多的情况下，轮流进入临界区并不是一个好办法。





### Peterson解法



### TSL指令

一种硬件支持的方案：

`TSL RX, LOCK` 称为**测试并加锁（test and set lock）**

* 它将一个内存字lock读到寄存器RX中，然后在该内存地址上存一个非零值。
* 这是一个原子操作。



锁住存储总线不同于屏蔽中断

* 屏蔽中断，然后在读内存字之后跟着写操作并不能阻止总线上的第二个处理器在读操作和写操作之间访问该内存字。



```shell
enter_region:
	# 复制锁到寄存器并将锁设为1
	TSL REGISTER, LOCK
	# 锁是零嘛？
	CMP REGISTER, #0
	# 若不是零，说明锁已被设置，所以循环
	JNE enter_region
	# 返回调用者，进入临界区
	
leave_region:
	# 在锁中存入0
	MOVE LOCK, #0
	# 返回调用者
	RET
```





### 睡眠与唤醒

> 优先级反转问题：
>
> 一台计算机有两个进程，H优先级较高，L优先级较低。调度规定，只要H处于就绪态它就可以运行。在某一时刻，L处于临界区中，此时H变到就绪态，准备运行。现在H开始忙等待，但由于当H就绪时L不会被调度，也就无法离开临界区，所以H将永远忙等待下去。



`sleep`是一个将引起调用进程阻塞的系统调用，即被挂起，直到另一个进程将其唤醒。

`wakeup`调用有一个参数，即要被唤醒的进程。





#### 生产者-消费者问题

















