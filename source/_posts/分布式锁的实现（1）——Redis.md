---
title: 分布式锁的实现（1）——Redis
date: 2021-03-08 16:34:22
tags: [分布式锁, Redis]
categories: 分布式系统
---

分布式锁一直是一个经常听到的名词，但是一直没有将它与普通的锁区分开来。这次打算来一次整理，具体了解一下分布式锁。



# 分布式锁背景

首先，分布式锁和我们平常讲到的锁原理基本一样，目的就是确保在多个线程并发时，只有一个线程在同一刻操作这个业务或者说方法、变量。

由于客观存在的业务量的需求，我们会把请求平均分配在多台服务器中。这里就可以把多台服务器理解成一个集群。分布式锁可以把整个集群就当做是一个应用一样去处理，那么也就需要这个锁独立于每一个服务之外，而不是在服务里面。这样一台机器接收到一个请求后，不能在自己的应用中完成闭环，需要向外请求整个服务。



# 分布式锁实现方式

* Redis
* Memcached
* ZooKeeper
* Chubby



# Redis

这篇文章就详细讲讲如何利用Redis来实现分布式锁。

首先，Redis是单线程的，这里的单线程指的是网络请求模块使用了一个线程（所以不需要考虑并发安全性），即一个线程处理所有网络请求，其他模块仍用了多个线程。



## 核心要素

我们需要首先了解分布式锁实现的三个核心要素：

1. 加锁

   最简单的方式是使用`setnx`命令。`key`是锁唯一标识，按业务来决定命名。

   加锁的伪代码如下：

   ```bash
   setnx(key, 1)
   ```

   当一个线程执行`setnx`返回1，说明`key`原本不存在，该线程成功得到了锁；当一个线程执行`setnx`返回0，说明`key`已经存在，该线程抢锁失败。

2. 解锁

   有加锁就得有解锁。当得到锁的线程执行完任务，需要释放锁，以便其他线程可以进入。释放锁的最简单方式是执行`del`指令，伪代码如下：

   ```bash
   del(key)
   ```

   释放锁之后，其他线程就可以继续执行`setnx`命令来获得锁。

3. 锁超时

   如果一个得到锁的线程在执行任务的过程中挂掉，来不及显示地释放锁，这块资源将会永远被锁住，别的线程再也别想进来。

   所以，`setnx`的`key`必须设置一个超时时间，以保证即使没有被显示释放，这把锁也要在一定时间后自动释放。`setnx`不支持超时参数，所以需要额外的指令，伪代码如下：

   ```bash
   expire(key, 30)
   ```

综上所述，我们分布式锁实现的第一版伪代码：

```java
if (setnx(key, 1) == 1) {
	expire(key, 30)
  try {
    // do something ...
  } finally {
    del(key)
  }
}
```



## 问题改进

但是上述这个伪代码还是存在着很多问题的

### setnx和expire的非原子性

设想一个极端场景，当某线程执行`setnx`，成功得到了锁。

`setnx`刚执行成功，还未来得及执行`expire`指令，节点宕机了。这样一来，这把锁就没有设置过期时间，别的线程再也无法获得锁了。



解决方案：

Redis2.6.12以上的版本为`set`指令增加了可选参数

```bash
set(key, 1, 30, NX)
```

这样就可以取代`setnx`指令



### del导致误删

假设线程A成功得到了锁，并且设置的超时时间是30秒。

可能存在某些原因导致线程A执行的很慢，过了30秒还没执行完，这时候锁过期自动释放，线程B得到了锁。

随后，线程A执行完了任务，线程A接着执行`del`指令来释放锁。但这时，线程B还没执行完，所以**线程A实际上删除的是线程B加的锁。**



解决方案：

可以在`del`释放锁之前做一个判断，验证当前的锁是不是自己加的锁。



```java
// 加锁
String threadId = Thread.currentThread().getId();
set(key，threadId ，30，NX);

// 解锁
if（threadId.equals(redisClient.get(key))）{
    del(key)
}
```



但是，这样做又隐含了一个新的问题，**判断和释放锁是两个独立操作，不是原子性**。

所以这一块要用Lua脚本来实现：

```lua
String luaScript = "if redis.call('get', KEYS[1]) == ARGV[1] then returnredis.call('del', KEYS[1]) else return 0 end";
redisClient.eval(luaScript , Collections.singletonList(key), Collections.singletonList(threadId));
```

这样一来，验证和删除过程就是原子操作了。



### 出现并发的可能性

虽然我们避免了线程A误删掉key的情况，但是同一时间有A, B两个线程在访问代码块，这仍然是不完美的。



解决方案：

可以让获得锁的线程开启一个守护线程，用来给快要过期的锁”续航“。

当过去了29秒，线程A还没执行完，这时候守护线程会执行`expire`指令，为这把锁”续命“20秒。

守护线程从第29秒开始执行，每20秒执行一次。当线程A执行完任务，会显示关掉守护线程。

另一种情况，如果线程A突然宕机，由于线程A和守护线程在同一个进程，守护进程也会停下。这把锁到了超时的时候，没人给它续命，就会自动释放。



# 参考资料

* [通俗讲解分布式锁，看完不懂算作者输](https://zhuanlan.zhihu.com/p/72896771)
* [漫画：什么是分布式锁](https://cloud.tencent.com/developer/article/1467797)



