---
title: 一致性大一统
date: 2021-03-01 11:07:47
tags: 一致性
categories: 分布式系统
---

在写这篇文章之前，对一致性的理解尚处于一种非常混乱的地步。很多名字搅在一起serializable, linearizable, sequential... 并没有一个很好的理解每一种模型之间的不同以及每一个模型背后的底层逻辑。这里准备整合一下网上的资料，阅读一些提出模型的论文来一个深度的理解。



[TOC]



# 一致性模型

下图向我们展示了在并发系统中常见的一致性模型之间的关系。箭头显示一致性模型之间的关系。例如，严格可串行化（Strict Serializable）意味着可串行化（Serializable）和可线性化（Linearizable），可线性化意味着序列一致性（Sequential）等等。颜色显示每个模型对于异步网络上的分布式系统的可用性。

{% asset_img consistency-model.png 一致性模型 %}



# 基础概念

## 系统 （Systems）

*分布式系统* 是*并发系统* 的一种类型，许多关于并发控制的文献直接应用于分布式系统。实际上，我们将要讨论的大多数概念最初都是针对单节点并发系统。但是，在可用性和性能方面存在一些重要的差异。

系统具有随时间变化的逻辑状态。例如，一个简单的系统可以是一个整数变量，状态为0、3和42。互斥只有两种状态：locked 或 unlocked。键值存储的状态可能是键到值的映射，例如：`{cat: 1, dog: 1}` 或 `{cat: 4}`。



## 进程（Processes）

进程是执行计算和运行操作的逻辑单线程程序。进程从来都不是异步的我们通过独立的进程来模拟异步计算。我们说“逻辑单线程”是为了强调，虽然一个进程一次只能做一件事，但它的实现可能会分布在多个线程、操作系统进程甚至物理节点上，只要这些组件提供了一致的单线程程序的假象。



## 操作（Operations）

操作是从一个状态到另一个状态的转换。例如，一个单变量系统可能有`read`和`write`这样的操作，分别获取和设置该变量的值。计数器可能具有`increments`、`decrements`和`reads`等操作。SQL存储可能有`selects`和`updates`等操作。



### 函数，参数和返回（Functions, Arguments & Return Values）

理论上，我们可以给每次状态转移一个唯一的名字。一个锁有两种状态：`lock`和`unlock`。一个整形的寄存器有无数种`read`和`write`：`read-the-value-1`, `read-the-value-2` 和 `write-1`,`write-2`...

为了让它更容易理解，我们把这些转换分解为`read`, `write`, `cas`, `increment`等 *函数（ function）*以及参数化这些函数的值（values）。在单寄存器系统中，write 1这个操作可以写成：

`{:f :write, :value 1}`

给定一个键值存储，我们可以将键“a”的值增加3，如下所示：

`{:f :increment, :value["a" 3]}`

在事务存储中，值可以是一个复杂的事务。在这里，我们读取a的当前值，找到2，并将b设置为3，在一个状态转换中：

`{:f :txn, :value [[:read "a" 2] [:write "b" 3]]}`



### 调用和完成时间（Invocation & Completion Time）

一般来说，操作都需要时间。在多线程程序中，操作可能是函数调用。在分布式系统中，操作可能意味着向服务器发送请求并接收响应。

为了对此进行建模，我们说每个操作都有一个*调用（ invocation）*时间，如果它完成了，则有一个更大的完成时间*（ completion time）*，这两个时间都由一个理想的，完美同步的，全局可访问的时钟给出。我们将这些时钟称为提供实时（real-time）顺序，而不是只跟踪因果顺序的时钟。



### 并发（Concurrency）

由于操作需要时间，两个操作可能会在某个时间点重合。例如，给定两个操作A和B，A可以开始，B可以开始，A可以完成，然后B可以完成。如果有一段时间A和B都在执行，那么我们说两个操作A和B是 *并发* 的。

进程是单线程的，这意味着由同一进程执行的两个操作永远不会并发。



### 崩溃（Crashes）

如果一个操作因为一些意外（可能是因为超时或者一个关键的组件崩溃了）没有执行成功，那么这个操作就 *没有完成时间（completion time）* 。并且通常必须在调用后被视为与每个操作并发。它可以执行也可以不执行。

具有某个操作的进程处于这种状态时，实际上会被卡住，并且永远不能再次调用另一个操作。如果它调用另一个操作，它将违反我们的单线程约束：进程一次只做一件事。



## Histories（历史）

*历史（ history）* 是操作的集合，包括它们的并发结构。

一些论文将其表示为一组操作，其中每个操作包含两个数字，表示它们的调用和完成时间；通过比较进程之间的时间窗口来推断并发结构。

Jepsen将历史表示为调用和完成操作的有序列表，有效地将每个操作一分为二。这种表示法对于迭代历史的算法更为方便，它保持了并发操作和可能状态的表示。



# 一致性模型

*一致性模型* 是一组历史。我们使用一致性模型来定义系统中哪些历史是“好的”，哪些是“合法的”。当我们说一个历史“违反了可序列化性”或“不可序列化”时，我们的意思是该历史不在可序列化历史的集合中。

如果A是B的子集，则一致性模型A意味着模型B。例如，线性化意味着序列一致性，因为每个可线性化的历史也是序列一致的。这允许我们在层次结构中关联一致性模型。

非正式地说，我们将更小、更严格的一致性模型称为“更强”，将更大、更宽松的一致性模型称为“较弱”。

并非所有的一致性模型都具有直接可比性。通常，两个模型允许不同的行为，但都不包含另一个。



## 一致性（Consistency）

数据库和分布式系统中都有一致性的概念，但是英文的文献也没有翻译出它们的区别，都是统一翻译成“Consistency”。

* 在数据库事务中的ACID中，C是Consistency，这里这个C主要强调应用逻辑的一致性，比如应用定义的约束，包括外键等。
  * 主要强调读是否能读到最新，以及并发场景下操作执行的时序关系，主要包括线性一致性（Linearizability），顺序一致性（Sequential Consistency），因果一致性（Causal Consistency）等；

* 分布式系统的CAP以及一致性协议，也称为一致性。
  * 主要强调“共识”，分布式中的多个节点对某个事情（leader选举，事务提交）达成一致，常见的共识算法包括paxos协议，raft协议。



## 正确性（Correctness）

> Given some *rules* which realte the operations and state, the history of operations in the system should always follow those rules.

要求我们的系统从头到尾必须遵循同一种一致性模型，那么我们就可以说这个系统具有正确性。



一致性模型的限制从最宽松到最严格可以被分为不同的档位。最宽松的一致性模型，允许所有的行为（即你的输出是什么都可以）。为了描述并发，就可以调整模型的限制。





## 严格可串行化 （Strict Serializability）

非正式地说，严格序列化意味着操作似乎以某种顺序发生，与这些操作的实时顺序一致；例如，如果操作A在操作B开始之前完成，那么A应该在序列化顺序中出现在B之前。

严格串行化是一种 *事务* 模型：操作（通常称为“事务”）可以包括按顺序执行的几个基本操作。严格的可序列化性保证了操作以原子方式进行：事务的子操作看起来不会与其他事务的子操作交织在一起。

它也是一个 *多对象* 属性：操作可以作用于系统中的多个对象。实际上，严格的序列化不仅适用于事务中涉及的特定对象，而且适用于整个系统——操作可能作用于谓词，如“所有cats的集合”。

严格的序列化功能不能完全或停滞可用；在网络分区的情况下，某些或所有节点将无法取得进展。

严格可串行化意味着可串行化和线性化。您可以将严格的可串行化看作是可串行化的事务性多对象操作的总顺序，再加上线性化的实时约束。或者，您可以将严格可序列化的数据库视为可线性化的对象，其中对象的状态是整个数据库。



### Formally

> A history is serializable if it is equivalent to one in which transactions appear to execute sequentiallly, i.e., without interleaving. A (partial) precedence order can be defined on non-overlapping pairs of transactions in the obvious way. A history is strictly serializable if the transcations' order in the sequential history is compatibel with their precedence order.







## 顺序一致性 （Sequential Consistency）

这个是出现在1979年的论文中



进程的操作可能会在调用之前或是调用之后生效，但仍然保证一个约束——任意进程中的操作必须按照进程中定义的顺序发生。



顺序一致性的性质：

1. 不要求操作按照真实的时间序发生。
2. 不同进程间的操作执行先后顺序也没有强制要求，但必须是原子的。
3. 单个进程内的操作顺序必须和编码时的顺序一致。



## 线性一致性 （Linearizability）

> An operation cannot take effect *before* its invocation. 
>
> No operation may take effect *after* its completion.

假设：

* 有一个全局的状态于每个进程进行通信
* 与这个全局状态交互的操作都是**原子的**
* **每个操作会在它调用和完成之间的某个时间点原子生效**



这样的模型就被称为**线性一致性模型**。尽管操作都是并发且耗时的，但每一个操作都会在某地以严格的线性顺序发生。相比于**顺序一致性**添加了时间维度。（顺序一致性中只有偏序关系）

“全局单点状态”并不一定是一个单独的节点，同样的，操作也并不一定全是原子的，状态也可以被分片成横跨多台机器，或者分多步完成——只要从进程的角度看来，外部记录的表现与**一个原子的单点状态等效**。一旦一个操作完成，它或它之后的某一状态将对**所有参与者可见**。

我们可以利用线性一致性的原子性约束来**安全地修改状态**。我们定义一个类似`CAS（compare-and-set）`的操作，当且仅当寄存器持有某个值的时候，我们可以往它写入新值。 `CAS`操作可以作为互斥量，信号量，通道，计数器，列表，集合，映射，树等等的实现基础，使得这些共享数据结构变得可用。线性一致性保证了变更的**安全交错**。

此外，线性一致性的时间界限保证了操作完成后，所有变更都对其他参与者可见。于是线性一致性禁止了过时的读。每次读都会读到某一介于`调用时间`与`完成时间`的状态，但永远不会读到读请求调用之前的状态。线性一致性同样禁止了**非单调**的读，比如一个读请求先读到了一个新值，后读到一个旧值。



保证：

1. *对于观察者来说，所有的读和写都在一个单调递增的时间线上串行地向前推进。*
2. *所有的读总能返回最近的写操作的值*。



{% asset_img 线性一致性和顺序一致性.png 线性一致性和顺序一致性 %}



## 因果一致性（Casual Consistency）

我们不必对一个进程中的**每个**操作都施加顺序约束。只有**因果相关**的操作必须按顺序发生。同样拿帖子举例子：一篇帖子下的所有评论必须以同样的顺序展示给所有人，并且只有帖子可见**后**，帖子下的回复才可见*（也就是说帖子和帖子下的评论有因果关系）*。如果我们将这些因果关系编码成类似“我依赖于操作X”的形式，作为每个操作明确的一部分，数据库就可以将这些操作延迟直到它们的依赖都就绪后才可见。

因果一致性比同一进程下对每个操作严格排序的一致性*（即顺序一致性）*来的更宽松——属于同一进程但不同因果关系链的操作能以相对的顺序执行*（也就是说按因果关系隔离，无因果关系的操作可以并发执行）*，这能防止许多不直观的行为发生。



{% asset_img 因果一致性.png 因果一致性 %}

每个线程自己认为所看到的是符合逻辑的就行。但不能保证每个线程看到的逻辑都是一样的。



## 串行一致性 （Serializable Consistency）

这是一个非常容易搞混的概念。原因在于数据库的隔离级别中有一个最高的隔离级别是可串行化（Serializable），这个是纯粹数据库领域的概念与分布式系统并没有交集。

对于数据库而言，Serializable是指在并发场景下，多个并发事务最终执行的序列与某个串行执行的序列相同（无事务并发，事务的执行没有重叠）。可以通过多种方式来实现，具体可见《数据密集型应用系统设计》读书笔记。



串行一致性允许对操作顺序执行任意的重排（只要操作顺序是原子序的）。



### Linearizability vs. Serializability

* Linearizability: single-operation, single-object, real-time order
  * 它对单个对象（例如，分布式寄存器或数据项）上的一组单个操作（通常是读写）的行为提供实时（即挂钟）保证。
* Serializability: multi-operation, multi-object, arbitrary total order
  * 它保证在多个项目上执行一组事务（通常包含读写操作）等同于事务的**某些**串行执行（总排序）。
* Serializability对事务的排序施加任何实质性约束，这一点与Linearizabililty不一样。
  * Serializability是不可组合的，它并不意味着任何类型的确定顺序，它只是要求存在一些等效的串行执行。



# 参考文献

[Consistency Models](https://jepsen.io/consistency)

[Linearizability vs. Serializablity](http://www.bailis.org/blog/linearizability-versus-serializability/)









