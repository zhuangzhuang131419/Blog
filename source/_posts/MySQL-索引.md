---
title: MySQL-索引
date: 2021-01-05 14:26:08
categories: 数据库
tags:
---
B树和B+树的具体结构在此不做赘述。好不容易弄明白了索引的底层实现，结果被面试官问为什么要使用B+索引，用Hash不香嘛。下了面试一查，发现居然还有Hash索引，真是吃了没有文化的亏呀。防不胜防，在此补作一笔。

首先要明白索引(index)是在存储引擎层面实现的，而不是server层面

# 什么是索引
索引（Index）是帮助数据库高效获取数据的数据结构。索引是在基于数据库表创建的，它包含一个表中某些列的值以及记录对应的地址，并且把这些值存储在一个数据结构中。最常见的就是使用哈希表、B+树作为索引。我们会为每一个字段去建索引。

# 从数据结构角度分类
实际上，还有Fulltext索引和R-Tree索引，但是这里简略带过。
* InnoDB存储引擎：默认是B+Tree 索引
* MyISAM存储引擎：默认是Fulltext 索引
* Memory存储引擎：默认Hash 索引。（也是可以使用B+Tree索引的）

## Hash索引
来，说说这个神奇的东西。Hash索引把数据以hash形式组织起来，因此当查找某一条记录的时候，速度非常快。但是因为hash结构，每个键只对应一个值，而且是散列的方式分布。**所以它并不支持范围查找和排序等功能。**

* Hash 索引无法完成排序
* 不支持最左匹配原则
* 在有大量重复键值情况下，Hash 索引的效率也很低
* 不支持范围查询

## B+Tree索引
相比Hash索引，B+Tree在查找单条记录的速度比不上Hash索引，但是因为更加适合排序等操作，所以更加受欢迎。(想起我跟面试官信誓旦旦的说B+Tree肯定查的快真是丢人😢)
* 带顺序访问指针的B+Tree
	* B+Tree所有的缩影数据都在叶子节点上，并且相比于B Tree增加了顺序访问指针，每个叶子结点都有指向相邻叶子节点的指针。
	* 这样做是为了提高区间效率，例如查询key为从18到49的所有数据记录，当找到18后，只要顺着节点和指针顺序遍历就可以以此向访问到所有数据节点，极大提高了区间查询效率。
* 大大减少磁盘I/O读取
	* 数据库系统的设计者巧妙利用了磁盘预读原理，将一个节点的大小设为等于一个页，这样每个节点需要一次I/O就可以完全载入。

## Full-Text全文索引
* 可以用全文索引代替效率较低的LIKE模糊匹配操作，而且可以通过多字段组合的全文索引一次性全模糊匹配多个字段。
* 同样适用B-Tree存放索引数据，但使用的是特定的算法，将字段数据分割后再进行索引，索引文件存储的是分割前的索引字符串集合，与分割后的索引信息，对应B-Tree结构的节点储存的是分割后的词信息以及它在分割前的索引字符串集合中的位置。

## R-Tree空间索引
* 空间索引是MyISAM的一种特殊索引类型，主要用于地理空间数据类型

# 从物理存储角度：聚簇索引与非聚簇索引
B+Tree索引可以分为聚簇缩影和非聚簇索引，但本质还是使用B+Tree实现的，即高度是平衡的，叶子节点存放所有的数据<b>聚集索引与非聚集索引的区别是：叶节点是否存放一整行记录。非聚簇索引是叶子节点存储的是索引+索引对应的记录的数据，聚簇索引是叶子节点上的数据是主键与具体记录(数据内容)</b>每张表只能有一个聚簇索引。

## 参考文献
https://juejin.im/post/5cdd701ee51d453a36384939

# 从逻辑角度分类
* 主键索引
  * 是一种特殊的唯一索引，不允许有空值。
* 唯一索引
  * 与“普通索引”类似，不同的就是：索引列的值必须唯一，但允许有空值。
* 普通索引
  * 最基本的索引，没有任何限制。
* 全文索引
  * 仅可用于MyISAM和InnoDB，针对较大的数据，生成全文索引很耗时耗空间。
* 倒排索引
  * 全文检索使用倒排索引来实现，倒排索引同B+树索引一样，也是一种数据结构，它在辅助表中存储了单词与单词自身在一个或多个文档中所在位置的映射，这通常利用关联数组实现。

  * 倒排索引它需要将分词（word）存储在一个辅助表（Auxiliary Table）中，为了提高全文检索的并行性能，共有6张辅助表。辅助表中存储了单词和单词在各行记录中位置的映射关系。它分为两种：<b>倒排文件索引</b>，<b>详细倒排索引</b>
    * Inverted file index 倒排文件索引，表现为{单词，单词所在文档ID}
    * Full inverted index 详细倒排索引，表现为{单词，(单词所在文档ID, 文档中的位置)}
  * [倒排索引为什么叫倒排索引？](https://www.zhihu.com/question/23202010)

## 组合索引
为了更多的提高mysql效率可建立组合索引，遵循"最左前缀"原则。创建复合索引应该将最常用（频率）做限制条件的列放在最左边，一次递减。组合索引最左字段用in是可以用到索引的。


## 覆盖索引
覆盖索引只一个查询语句的执行只用从索引中就能够取得，不必从数据表中读取。如果一个索引包含(或覆盖)满足查询语句中字段与条件的数据就叫做覆盖索引。


# 最左匹配原则
最左匹配原则就是指在联合索引中，如果你的 SQL 语句中用到了联合索引中的最左边的索引，那么这条 SQL 语句就可以利用这个联合索引去进行匹配。
>示例1 

假设有索引(a,b,c)
```SQL
select * from t where a=1 and b=1 and c =1;     #这样可以利用到定义的索引（a,b,c）

select * from t where a=1 and b=1;     #这样可以利用到定义的索引（a,b,c）

# 借助mysql查询优化器explain，explain会纠正sql语句该以什么样的顺序执行效率最高，最后才生成真正的执行计划。
select * from t where b=1 and a=1;     #这样可以利用到定义的索引（a,b,c）

select * from t where a=1;     #这样也可以利用到定义的索引（a,b,c）

select * from t where b=1 and c=1;     #这样不可以利用到定义的索引（a,b,c）

select * from t where a=1 and c=1;     #这样不可以利用到定义的索引（a,b,c）

# 当遇到范围查询(>、<、between、like)就会停止匹配
select * from t where a=1 and b>1 and c =1;     #这样a,b可以用到（a,b,c），c不可以

```

>示例2

假设对列```col1```,```col2```,```col3```建立一个联合索引

```SQL
KEY test_col1_col2_col3 on test(col1,col2,col3)
```
联合索引```test_col1_col2_col3```实际上建立了```(col1)```,```(col1,col2)```,```(col1,col2,col3)```三个索引

```SQL
SELECT * FROM test WHERE col1=“1” AND clo2=“2” AND clo4=“4”
```
上面这个查询语句执行时会依照最左前缀匹配的原则，检索时会使用索引```(col1,col2)```进行数据匹配

## 最左匹配原则的原理

因为构建一颗B+树只能根据一个值来构建，因此数据库依据联合索引最左的字段来构建B+树
> 示例

假如创建一个(a,b,c)的联合索引

{% asset_img 最左匹配原理.png 最左匹配原理 %}

该图就是一个形如(a,b,c)联合索引的 b+ 树，其中的非叶子节点存储的是第一个关键字的索引 a，而叶子节点存储的是三个关键字的数据。这里可以看出 a 是有序的，而 b，c 都是无序的。但是当在 a 相同的时候，b 是有序的，b 相同的时候，c 又是有序的。通过对联合索引的结构的了解，那么就可以很好的了解为什么最左匹配原则中如果遇到范围查询就会停止了。以 ```select * from t where a=5 and b>0 and c =1; ```这样a,b可以用到（a,b,c），c不可以 为例子，当查询到 b 的值以后（这是一个范围值），c 是无序的。所以就不能根据联合索引来确定到低该取哪一行。

# 参考文献
https://www.cnblogs.com/aspirant/p/9214485.html

